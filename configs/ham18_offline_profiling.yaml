# configs/ham18_offline_profiling.yaml

experiment:
  name: ham18_offline_profiling
  output_dir: ./logs/ham18_offline_profiling

seed: 42

data:
  dataset: ham10000
  root: ./data/ham10000
  num_classes: 7
  img_size: 224
  train_val_split: [0.8, 0.2]
  num_workers: 4
  batch_size: 256
  bytes_per_elem: 4              # float32
  augmentation:
    random_horizontal_flip: true
    random_vertical_flip: false
    color_jitter: false
  iid: true                      # IID 划分数据集

model:
  backbone: resnet18
  pretrained: false
  in_channels: 3

usfl:
  mode: profiling                # 这里是离线分析模式
  num_clients: 5                 # 客户端数量
  local_steps: 1                 # 每轮通信前每个客户端本地更新步数
  aggregation: fedavg            # 后面 aggregation.py 里用这个 key
  split:
    frontend_cut_range: [0, 5]   # 前端切分层范围
    backend_cut_range: [0, 5]    # 后端切分层范围

training:
  device: cuda
  epochs: 100
  mixed_precision: true          # 混合精度训练，用 torch.cuda.amp 可以减一点通信时间
  grad_clip: 5.0                 # 0 或 None 表示不裁剪
  eval_every: 1                  # 每多少个 epoch 跑一次验证
  save_every: 10                 # 每多少个 epoch 存一次 checkpoint

simulation:
  comm:
    mode: fixed
    bw_up_mbps: 80.0
    bw_down_mbps: 80.0
    rtt_ms: 10.0
    temporal_corr: 0.0           # 不随时间变
    jitter_std: 0.0
  comp:
    kappa_client: 10             # 客户端计算能力系数，用于缩放计算时间
    kappa_server: 1              # 服务器计算能力系数，用于缩放计算时间

optimizer:
  type: adam                     # sgd / adam
  lr: 1e-4
  weight_decay: 0.0

metrics:
  average: macro                 # precision / recall / F1 计算方式：macro / micro / weighted
  multi-class: ovr               # AUC 计算方式：ovr / ovo

logging:
  log_interval: 1                 # 每多少个 iteration 打一次日志
  save_checkpoints: true
  tensorboard: true
  train_csv: train_metrics.csv
  val_csv: val_metrics.csv
  j_score_csv: j_scores.csv         # 存各切分点 J 值的文件
  static_cost_csv: static_costs.csv # 存各切分点静态成本的文件
  feature_csv: features.csv         # 存各切分点特征的文件
  scale_csv: scales.csv             # 存通信成本、计算成本归一化尺度的文件

privacy:
  enable: true
  aux_dataset:
    name: derm7pt               # ham10000 场景默认 derm7pt
    root: ./data/Derm7pt_release_v0
    split: all                  # all data 用于辅助攻击器训练
    num_workers: 4
    batch_size: 64
    max_samples: 5000           # 每个 cut 最多采样多少个样本
    store_x: true               # 是否同时保存原始图像 x（MIA 需要）
  sae:                          # SAE-SL 攻击器配置
    enable_lia: true
    enable_mia: true
    weight_lia: 0.5             # P_global = w_l * P_label + w_s * P_sample
    weight_mia: 0.5
    lambda_lia: 1.0             # 多任务训练中的 CE 权重
    lambda_mia: 1.0             # 多任务训练中的重建损失权重
    lia_algorithm: mix-match
    force_retrain: false
    epochs: 20
    lr: 1.0e-3
    weight_decay: 1.0e-4
    mixmatch:
      labeled_fraction: 0.1
      T: 0.5
      alpha: 0.75
      lambda_u: 75.0
      use_augmentation: true   # 如需更贴 Fu 的 “customized no-aug”，设 false
    patience: 5
    lia_hidden_dim: 256
    lia_dropout: 0.0
    save_attacker_ckpt: true
    decoder_channel_min: 32
    decoder_out_act: sigmoid
  metrics:
    lia_to_priv: auc_identity   # 先用 P_label = AUC
    mia_metric: mse             # 重建质量指标类型：mse / psnr / ssim（先用 mse）
    mia_scale: 1.0              # 将质量映射到 [0,1] 时的缩放，先占位

objective:
  acc_mode: final                # accuracy 计算方式：final / best
  # J 值计算默认等权重
  weights:
    acc_cost: 1
    comm: 1
    comp: 1
    privacy: 1
  normalize_method: minmax       # 离线分析采用 min-max 归一化
