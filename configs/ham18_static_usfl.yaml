# configs/ham18_static_usfl.yaml

experiment:
  name: ham18_static_usfl
  output_dir: ./logs/ham18_static_usfl

seed: 42

data:
  dataset: ham10000
  root: ./data/ham10000
  num_classes: 7
  img_size: 224
  train_val_split: [0.8, 0.2]
  num_workers: 4
  batch_size: 256
  bytes_per_elem: 4              # float32
  augmentation:
    random_horizontal_flip: true
    random_vertical_flip: false
    color_jitter: false
  iid: false                     # 非 IID 划分数据集

model:
  backbone: resnet18
  pretrained: false
  in_channels: 3

usfl:
  mode: static                   # 这里是静态切分 baseline
  num_clients: 5                 # 客户端数量
  local_steps: 1                 # 每轮通信前每个客户端本地更新步数
  aggregation: fedavg            # 后面 aggregation.py 里用这个 key
  split:
    j_score_csv: ./logs/ham18_offline_profiling/scales.csv  # 离线分析得到的 J 值文件

training:
  device: cuda
  epochs: 100
  mixed_precision: true          # 混合精度训练，用 torch.cuda.amp 可以减一点通信时间
  grad_clip: 5.0                 # 0 或 None 表示不裁剪
  eval_every: 1                  # 每多少个 epoch 跑一次验证
  save_every: 10                 # 每多少个 epoch 存一次 checkpoint

simulation:
  comm:
    mode: fixed
    bw_up_mbps: 80.0
    bw_down_mbps: 80.0
    rtt_ms: 10.0
    temporal_corr: 0.0           # 不随时间变
    jitter_std: 0.0
  comp:
    kappa_client: 10             # 客户端计算能力系数，用于缩放计算时间
    kappa_server: 1              # 服务器计算能力系数，用于缩放计算时间

optimizer:
  type: sgd                      # sgd / adam
  lr: 0.01
  momentum: 0.9
  weight_decay: 5e-4

metrics:
  average: macro                 # precision / recall / F1 计算方式：macro / micro / weighted
  multi-class: ovr               # AUC 计算方式：ovr / ovo

logging:
  log_interval: 10               # 每多少个 iteration 打一次日志
  save_checkpoints: true
  tensorboard: true              # 如果你准备接 TensorBoard 的话
  train_csv: train_metrics.csv
  val_csv: val_metrics.csv

privacy:
  enable: true
  aux_dataset:
    name: derm7pt               # ham10000 场景默认 derm7pt
    root: ./data/derm7pt
    split: train                # official split / train
    num_workers: 4
    max_samples: 5000           # 每个 cut 最多采样多少个样本
    store_x: true               # 是否同时保存原始图像 x（MIA 需要）
  sae:                          # SAE-SL 攻击器配置
    enable_lia: true
    enable_mia: true
    weight_lia: 0.5             # P_global = w_l * P_label + w_s * P_sample
    weight_mia: 0.5
    lambda_lia: 1.0             # 多任务训练中的 CE 权重
    lambda_mia: 1.0             # 多任务训练中的重建损失权重
    lia_algorithm: mix-match
    force_retrain: false
    epochs: 20
    lr: 1.0e-3
    weight_decay: 1.0e-4
    mixmatch:
      T: 0.5
      alpha: 0.75
      lambda_u: 75.0
      use_augmentation: true   # 如需更贴 Fu 的 “customized no-aug”，设 false
    patience: 5
    lia_hidden_dim: 256
    lia_dropout: 0.0
    attacker_ckpt_dir: ./checkpoints/privacy/sae
    decoder_channel_min: 32
    decoder_out_act: sigmoid
  metrics:
    lia_to_priv: auc_identity   # 先用 P_label = AUC
    mia_metric: mse             # 重建质量指标类型：mse / psnr / ssim（先用 mse）
    mia_scale: 1.0              # 将质量映射到 [0,1] 时的缩放，先占位

objective:
  acc_mode: final                # accuracy 计算方式：final / best
  # J 值计算默认等权重
  weights:
    acc_cost: 1
    comm: 1
    comp: 1
    privacy: 1
  normalize_method: scale        # 默认缩放
  scale_csv: ./logs/ham18_offline_profiling/scales.csv
